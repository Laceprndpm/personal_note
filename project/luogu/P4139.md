---
title: 上帝与集合的正确用法
date: 2025-12-12
last_clear: 2025-12-12
tags:
  - luogu
  - tag/math
grasp:
value:
difficulty:
optional_difficulty:
source:
article:
---
**拓展欧拉定理：** 若要求 $a^k \bmod m$，当 $\gcd(a, m) \ne 1$ 时不可直接降幂，应使用 $a^{k \bmod \varphi(m) + \varphi(m)} \bmod m ,\; k\ge\varphi(m)$，其中 **`+ φ(m)` 不可省略**，否则当 $k < \varphi(m)$ 时可能出现错误结果。
Note:
$m\rightarrow \varphi(m) \rightarrow \varphi(\varphi(m)) \dots \rightarrow 1$ 不会超过 $2\log(m)$ 次，因此求 $a_1^{a_2^{a_3^{\cdots}}} \bmod m$ 只需要往上求 $2\log(n)$ 次。
>对于嵌套幂塔 $a_1^{a_2^{a_3^{\cdots}}} \bmod m$，我们可以递归构造模链 $m, \varphi(m), \varphi(\varphi(m)), \dots$，直到为 $1$，并自顶向下构造指数，自底向上模运算。由于 $\varphi(n) \le n/2$，模链长度不超过 $2\log m$，因此只需递归构造 $O(\log m)$ 层即可精确求值。


```py
N = int(1e7)
phi = [0] * (N + 1)
is_prime = [True] * (N + 1)
primes = []
phi[1] = 1
for i in range(2, N + 1):
    if is_prime[i]:
        primes.append(i)
        phi[i] = i - 1
    for p in primes:
        if i * p > N:
            break
        is_prime[i * p] = False
        if i % p == 0:
            phi[i * p] = phi[i] * p
            break
        else:
            phi[i * p] = phi[i] * (p - 1)


T = int(input())


def solve(p):
    if p == 1:
        return 0
    return pow(2, solve(phi[p]) % phi[p] + phi[p], p)


for _ in range(T):
    n = int(input())
    print(solve(n))

```