---
title: 子集
date: 2025-07-21
last_clear: 2025-07-21
tags:
  - tag/math/线性代数/线性基
grasp: 2
difficulty: 1900
source: https://acm.hdu.edu.cn/contest/problem?cid=1173&pid=1012
article:
---
# 题意
**请注意本题特殊的空间限制**。
给出一个长度为 n 的非负整数序列 a，你可以在这些数中选取任意个数（可以是零个），但不能选取相邻的数，求选出来的数的异或和最大值。
## Input
每个测试点中包含多组测试数据。输入的第一行包含一个正整数 $T(1\le T\le 3)$，表示数据组数。对于每组测试数据：
第一行一个正整数 $n(1\le n\le 50)$，表示序列长度。
第二行 $n$ 个非负整数 $a_1,a_2,⋯ ,a_n(0\le a_i \le 10^{18})$，表示序列 a。
## Ouput
对于每组测试数据：输出一行一个整数，表示答案。
## 约束
Time Limit (Java / Others)
6000 / 3000 MS

Memory Limit (Java / Others)
6144 / 3072 K
# Solution
## 线性基
因为是顺序dfs，所以直接删除上一个插入点即可
如果使用cpp的iostream，因为有缓冲区，所以会额外消耗1MB的内存
```cpp showLineNumbers title="P12.cpp"
struct Basis {
	// Basis
    void retreat(int idx)
    {
        basis_arr[idx] = 0;
    }
}
void dfs(int cur)
{
    if (cur >= n) {
        ans = max<u64>(ans, b.qmax());
        return;
    }
    int idx1 = b.ins(arr[cur]);
    dfs(cur + 2);
    if (idx1 != -1) b.retreat(idx1);
    if (cur + 1 < n) {
        int idx2 = b.ins(arr[cur + 1]);
        dfs(cur + 3);
        if (idx2 != -1) b.retreat(idx2);
    }
}

void solve()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%llu", (unsigned long long*)(arr + i));
    }
    b.init();
    ans = 0;
    dfs(0);
    printf("%llu\n", (unsigned long long)ans);
}
```
