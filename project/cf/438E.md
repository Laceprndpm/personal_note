---
title: E. The Child and Binary Tree
date: 2025-08-31
last_clear: 2025-08-31
tags:
  - tag/math/fftntt
  - tag/math/多项式和生成函数
grasp: 2
difficulty: 3100
source: https://codeforces.com/contest/438/problem/E
article:
---
# 题意
给定集合 ${c_1, c_2, ..., c_n}$，有根二叉树的每个结点的权值都属于这个集合。  
有根二叉树的权值定义为这棵树上所有结点的权值和，对 $s = 1, 2, ..., m$，求有多少不同的有根二叉树的权值为 $s$，方案数模 $998244353$。  
（左子树和右子树可以区分）
$(1 \leq n, m, c_i \leq 10^5)$
# Solution
既然是计算方案数，类比糖果游戏，可以设
$c(x)= \sum{x^{c_i}} \quad \text{where } c_i \in C$
设 $F(x)$，其中$[x^k]F(x)$ 表示组合出权值为 $k$ 的二叉树的方案数。
可以由二叉树写出
$$
F(x) = c(x)F^2(x) + 1
$$
`+1` 是因为空二叉树只有一种，而 $c(0) = 0$，因此每次要重新补上这个 `1`
## 1-求解形式幂级数
$$
c(x)F^2(x) - F(x) + 1 = 0
$$
$$
x = \frac{1 \pm \sqrt{1 - 4 c(x)}}{2c(x)}
$$
有两个解，而答案只有一个
为了确保有解，即形式幂级数合理
我们注意到，$c_0 = 0$ ，不存在逆。
因此
1. 当为加号，分子的常数项为2，分母为0，无解
2. 当为减号，分子常数项也为0，同时，由于保证有解，所以可以找到分母的最低位$x^u$ ，令分母除以 $x^u$ 
可以保证分母最低位高于分子最低位(否则无解)
### Code:
```c++
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> ci(n);
    for (int &i : ci) {
        cin >> i;
    }
    auto [mnit, mxit] = minmax_element(all(ci));
    int   mn = *mnit, mx = *mxit;
    PolyZ cx(mx + 1);
    for (int i : ci) {
        cx[i] = 1;
    }
    int  need_reserve = mn + m + 1;
    auto below        = (cx * 2).shift(-mn).inv(m + 1);
    auto up1          = PolyZ{1} - (PolyZ{1} - 4 * cx).sqrt(need_reserve);
    for (int i = 0; i < mn; i++) {
        assert(up1[i].val() == 0);
    }
    up1      = up1.shift(-mn);
    auto ans = (up1 * below).trunc(m + 1);
    for (int i = 1; i <= m; i++) {
        cout << ans[i] << '\n';
    }
}
```
## 2-Newton迭代法
$$
G(F(x)) = c(x)F^2(x) - F(x) + 1 = 0
$$
通过带入$x = 0$
可以得到
$$
F_1(x) = 1
$$

$$
F_{2n} = F_n - \frac{G(F_n(x))}{G'(F_n(x))}
$$

$$
G' = \frac{\partial G(F(x))}{\partial F(x)} = 2c(x)F(x) - 1
$$
$$
F_{2n} = F_n - \frac{c(x){F_n}^2(x) - F_n(x) + 1}{2c(x)F_n(x) - 1}
$$
```c++
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> ci(n);
    for (int &i : ci) {
        cin >> i;
    }
    int   mxval = *max_element(all(ci));
    PolyZ cx(mxval + 1);
    for (int i : ci) {
        cx[i] = 1;
    }
    auto newtonres = [&](int x) {
        int   k  = 1;
        PolyZ fx = {1};
        while (k < x) {
            k *= 2;
            auto cxt = cx.trunc(k);
            fx       = fx - (cxt * fx * fx - fx + PolyZ{1}) * (2 * cxt * fx - PolyZ{1}).inv(k);
            fx       = fx.trunc(k);
        }
        return fx.trunc(x);
    }(m + 1);
    for (int i = 1; i <= m; i++) {
        cout << newtonres[i] << '\n';
    }
}
```
