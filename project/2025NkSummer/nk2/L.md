---
title: Love Wins All
date: 2025-07-21
last_clear: 2025-07-21
tags:
  - tag/dsu
grasp: 4
difficulty: 1400
source: https://ac.nowcoder.com/acm/contest/108299/L
article:
---
# 题意
充满爱的社区婚姻计划问题

这是一个充满爱的社区！  

社区中有 $n$ 名居民，每位居民 $i$ ($1 \le i \le n$) 在社区中都有一个他/她非常爱的居民 $a_i$ ($1 \le a_i \le n$)。  
每两个居民爱着不同的居民。居民可以爱自己。保证 $n$ 是偶数。  

有一天，发生了一件坏事：他们需要选择 2 名居民，他们将永远被禁止结婚。  

为了防止将来发生这样的事情，其余的 $n-2$ 名居民会组成 $\frac{n}{2}-1$ 组对象结婚，每组对象由 2 个人组成（当然）。  
如果一组对象由居民 $x$ 和居民 $y$ 组成，而 $x$ 既不爱 $y$，$y$ 也不爱 $x$，那这也太怪了！因此这样的情况永远不会发生。  

因此，作为婚姻规划者，您需要弄清楚如何安排这一切。  
您想知道不同婚姻计划的数量。两个婚姻计划是不同的，当且仅以下条件至少其一为真：  

- 在一个计划中，某人 $i$ 已婚，而在另一个计划中，他/她未婚。  
- 在一个计划中，某人 $i$ 与 $j$ 结婚，而在另一个计划中，他/她没有与 $j$ 结婚。  

由于计划的数量可能非常多，请输出数量关于 $998\,244\,353$ 取模的结果。
## 形式化
给定一个长度为 $n$ 的排列 $P$，其中 $n$ 是偶数。  

问有多少种形成 $\frac{n-2}{2}$ 个数对的方式，使得数对中出现了 $n-2$ 个不同的元素，  
且对于其中任一个数对 $(x_i, y_i)$ 满足：
$$
P[x_i] = y_i \quad \text{或} \quad P[y_i] = x_i
$$
结果关于 $998\,244\,353$ 取模后输出。
- $4 \le n \le 5 \cdot 10^5$
# Solution
## std
考虑将排列转为图，即将排列视作有 $n$ 个点的无向图，并将 $i, P[i]$ 之间连一条边。  

这个图由一系列环组成。最终的方案等价于其中取 $\frac{n-2}{2}$ 条边，使得选择的边之间没有公共点（这里如果两条边都是 $u, v$ 之间的认为是一种方案）。相当于去掉两个点后，剩余的图完全匹配的方案数的和。  

图中，奇环的数量一定是偶数，因为环的点数和是 $n$，一个偶数。  

如果奇环的数量不小于 4，则删去两个点后，一定还有奇环，而奇环无法完全匹配，因此方案数为 0。  

如果奇环的数量等于 2，则删去的两个点一定分别来自两个奇环。可以删去环上的任意点，剩余一条链的完全匹配唯一确定。如果剩余环的大小是 2，则只有 1 种方案；否则有 2 种方案。  

如果奇环的数量等于 0，则删去的两个点都只能在一个环上。考虑枚举操作的环，假设环的大小为 $n$，对环上的点进行黑白交替染色，则为了剩余的点可以形成最大匹配，一定选一黑一白两个点（因为匹配的两点一定一黑一白）。同时，如果选了一黑一白，剩余的点一定能形成完全匹配，所以方案数是 $\frac{n^2}{4}$。最后需要乘以剩余环的总方案数（统计有几个非二元环），再对各个环求和。  

时间复杂度为 $O(n)$。  

也可以尝试本题的更难情况，即输入不保证是排列。
## my
```c++
void solve()
{
    int n;
    cin >> n;
    vector<int> love(n + 1);
    for (int i = 0; i < n; i++) {
        cin >> love[i];
        love[i]--;
    }
    DSU dsu(n);
    for (int i = 0; i < n; i++) {
        dsu.merge(i, love[i]);
    }
    auto res = dsu.getGroups();

    int cnt_odds = 0;
    for (auto &it : res) {
        if (sz(it) % 2) {
            cnt_odds++;
        }
    }
    vector<int> vec;
    vector<int> odds;
    int         len2 = 0;
    for (auto &it : res) {
        if (sz(it) % 2) {
            odds.eb(sz(it));
        } else if (sz(it) != 2) {
            vec.eb(sz(it));
        } else {
            len2++;
        }
    }
    if (cnt_odds == 0) {
        Z ans = 0;
        for (i64 len : vec) {
            ans += Z(len / 2) * Z(len / 2) * power(Z(2), sz(vec) - 1);
        }
        for (int i = 0; i < len2; i++) {
            ans += 1ll * power(Z(2), sz(vec));
        }
        cout << ans << '\n';
    } else if (cnt_odds == 2) {
        Z ans = Z(odds[0]) * odds[1];
        ans *= power(Z(2), sz(vec));
        cout << ans << '\n';
    } else {
        cout << 0 << '\n';
    }
}
```