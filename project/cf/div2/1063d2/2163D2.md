---
title: D2. Diadrash (Hard Version)
date: 2025-11-27
last_clear: 2025-11-28
tags:
  - div2
  - tag/二分搜索
  - tag/贪心
grasp: 4
value: 5
difficulty: 2500
optional_difficulty:
source: https://codeforces.com/contest/2163/problem/D2
article:
---
只能进行 `30` 次查询，逼迫我往二分方向思考($\lceil \log_2(1e4) \rceil = 14$)，随后我注意到，如果我直接对那 $n$ 个有效区间进行二分，会出现跳跃，比如所有区间都是长度为1000的区间，而0和1间刚刚好有998个数，那么这告诉我们，查询一定不能只在有效区间里，而又要受到有效区间的限制。同时又因为是 MEX，而MEX递增的条件很苛刻，即如果想递增，必须要包含某一个特定的数。所以我刚刚好想到可以直接对有效区间排序后，先查询 $l, r$  作为 $cur$ ，再查询 $l, n$ 作为 $future$ ，即继续向右拓展能不能变大。然后二分一下，查询次数刚刚好为 $2 \times 14 = 28$ 
```cpp showLineNumbers
int cnt = 0;

int query(int l, int r)
{
    cnt++;
    if (cnt > 30) exit(-1);
    cout << '?' << ' ' << l << ' ' << r << endl;
    int res;
    cin >> res;
    return res;
}

void solve()
{
    cnt = 0;
    int n, q;
    cin >> n >> q;
    vector<pair<int, int>> candidate;
    for (int i = 0; i < q; i++) {
        int a, b;
        cin >> a >> b;
        candidate.pb({a, b});
    }
    int ans = 0;
    sort(all(candidate), [](auto a, auto b) {
        if (a.fi == b.fi) {
            return a.se > b.se;
        }
        return a.fi < b.fi;
    });
    vector<pair<int, int>> chooseN;
    int                    last_r = 0;
    for (auto [l, r] : candidate) {
        if (r <= last_r) {
            continue;
        }
        last_r = r;
        chooseN.pb({l, r});
    }
    int l = 0, r = chooseN.size();
    while (l < r) {
        int mid    = (l + r) / 2;
        int cur    = query(chooseN[mid].fi, chooseN[mid].se);
        int future = query(chooseN[mid].fi, n);
        ans        = max(cur, ans);
        if (cur < future) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    cout << '!' << ' ' << ans << endl;
}
```
