---
title: F. Piet's Palette
date: 2025-08-13
last_clear: 2025-08-13
tags:
  - tag/math/线性代数/高斯消元
grasp: 1
difficulty: 3200
source: https://codeforces.com/contest/1344/problem/F
article: https://ac.nowcoder.com/study/live/731/6/1
---
# 题意
一个长度为 $n$ `'RBY'` 序列，四种操作：
- **mix** $j_1\ j_2\ \dots\ j_m$ ：把序列的第 $j_i$ 位按顺序取出，从左到右做合并操作：
  - 如果前两个同色，则删去；
  - 如果前两个异色，则变为另一个颜色；
  - 如果只剩一个，则最终答案就是它，否则答案是 W。
- **RY** $j_1\ j_2\ \dots\ j_m$ ：将序列中的 R 变为 Y，Y 变为 R。
- **RB** $j_1\ j_2\ \dots\ j_m$ ：将序列中的 R 变为 B，B 变为 R。
- **YB** $j_1\ j_2\ \dots\ j_m$ ：将序列中的 Y 变为 B，B 变为 Y。
给出 $k$ 次操作和每个 **mix** 操作的结果，求原始序列。  
$$(1 \le n, k \le 1000)$$
# Solution
需要观察到
Yellow -> 1
Red -> 2
Blue -> 3
那么 `mix` 操作就相当于全部异或起来
而异或相当于对每位 mod 2 加法
随后向量化方便高斯消元求解
即
Yellow = 01 = $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$
Red = 10 = $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$
Blue = 11 = $\begin{bmatrix} 1 \\ 1 \end{bmatrix}$

但随后，三个操作的切换不方便我们构造同余方程
把切换变成矩阵乘法
RY=
$\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}$
RB=
$\begin{bmatrix} 1 & 0 \\ 1 & 1 \end{bmatrix}$
YB=
$\begin{bmatrix} 1 & 1 \\ 0 & 1 \end{bmatrix}$
可能有多种实现，但大多绕不过这种变换。
随后就是标准的高斯消元，将主元变量设置为结果，那么自由变量就设为0
## 实现
Benq:
```c++
int                  n, k;
int                  col[1000][4];
vector<bitset<2001>> b;

void swa(int x, int a, int b)
{
    int i                           = -1;
    F0R(z, 4) if (col[x][z] == a) i = z;
    int j                           = -1;
    F0R(z, 4) if (col[x][z] == b) j = z;
    assert(i != -1 && j != -1);
    swap(col[x][i], col[x][j]);
}

int main()
{
    setIO();
    re(n, k);
    F0R(i, n) F0R(j, 4) col[i][j] = j;
    // is red -> 2, is yellow -> 1
    F0R(i, k)
    {
        str s;
        int m;
        re(s, m);
        if (s == "mix") b.eb(), b.eb();
        F0R(j, m)
        {
            int x;
            re(x);
            x--;
            if (s == "RY")
                swa(x, 2, 1);
            else if (s == "RB")
                swa(x, 2, 3);
            else if (s == "YB")
                swa(x, 1, 3);
            else {
                assert(s == "mix");
                // 这里直接在矩阵中构造2x2矩阵
                // 第一行意味着红分量，第二行代表黄分量
                // 红黄交换就相当于互换
                // 如果有一个颜色和蓝色互换，则代表其拥有两个分量
                if (col[x][2] & 2) b[sz(b) - 2][2 * x] = 1;
                if (col[x][2] & 1) b[sz(b) - 1][2 * x] = 1;
                if (col[x][1] & 2) b[sz(b) - 2][2 * x + 1] = 1;
                if (col[x][1] & 1) b[sz(b) - 1][2 * x + 1] = 1;
            }
        }
        if (s == "mix") {
            char res;
            re(res);
            if (res == 'R' || res == 'B') b[sz(b) - 2][2000] = 1;
            if (res == 'Y' || res == 'B') b[sz(b) - 1][2000] = 1;
        }
    }
    int cur = 0;
    F0R(z, 2001)
    {
        FOR(i, cur, sz(b)) if (b[i][z] == 1)
        {
            swap(b[i], b[cur]);
            assert(b[cur][z] == 1);
            F0R(j, sz(b)) if (j != cur && b[j][z]) b[j] ^= b[cur];
            cur++;
            break;
        }
    }
    vi tmp(n);
    F0R(i, sz(b))
    {
        int ind = 0;
        while (ind < 2001 && !b[i][ind]) ind++;
        if (ind == 2001) continue;
        if (ind == 2000) {
            ps("NO");
            exit(0);
        }
        assert(ind < 2 * n);
        if (ind % 2 == 0)
            tmp[ind / 2] += 2 * b[i][2000];
        else
            tmp[ind / 2] += b[i][2000];
    }
    ps("YES");
    F0R(i, n)
    {
        if (tmp[i] == 3)
            pr('B');
        else if (tmp[i] == 2)
            pr('R');
        else if (tmp[i] == 1)
            pr('Y');
        else
            pr('.');
    }
    ps();
    // you should actually read the stuff at the bottom
}
```
同构实现：
```c++
using M22               = OMatrix<short, 2, 2>;
M22                  RY = {{0, 1}, {1, 0}};
M22                  RB = {{1, 0}, {1, 1}};
M22                  YB = {{1, 1}, {0, 1}};
vector<bitset<2001>> b;

void solve()
{
    int n, k;
    cin >> n >> k;
    vector<M22> col(1000);
    for (auto &i : col) {
        i = M22{{1, 0}, {0, 1}};
    }
    FOR(i, k)
    {
        string s;
        cin >> s;
        if (s == "mix") {
            b.eb();
            b.eb();
        }
        int m;
        cin >> m;
        FOR(j, m)
        {
            int x;
            cin >> x;
            x--;
            if (s == "RY") {
                col[x] = RY * col[x];
            } else if (s == "RB") {
                col[x] = RB * col[x];
            } else if (s == "YB") {
                col[x] = YB * col[x];
            } else {
                assert(s == "mix");
                for (int i = 0; i < 2; i++) {
                    assert(col[x].data[i][0] < 2);
                    assert(col[x].data[i][1] < 2);
                }
                if (col[x].data[0][0]) b[sz(b) - 2][x * 2] = 1;
                if (col[x].data[1][0]) b[sz(b) - 1][x * 2] = 1;
                if (col[x].data[0][1]) b[sz(b) - 2][x * 2 + 1] = 1;
                if (col[x].data[1][1]) b[sz(b) - 1][x * 2 + 1] = 1;
            }
        }
        if (s == "mix") {
            char res;
            cin >> res;
            if (res == 'R' || res == 'B') b[sz(b) - 2][2000] = 1;
            if (res == 'Y' || res == 'B') b[sz(b) - 1][2000] = 1;
        }
    }
    int cur = 0;
    FOR(z, 2001)
    {
        FOR(i, cur, sz(b)) if (b[i][z] == 1)
        {
            swap(b[i], b[cur]);
            assert(b[cur][z] == 1);
            FOR(j, sz(b)) if (j != cur && b[j][z]) b[j] ^= b[cur];
            cur++;
            break;
        }
    }
    vector<int> tmp(n);
    FOR(i, sz(b))
    {
        int ind = 0;
        while (ind < 2001 && !b[i][ind]) ind++;
        if (ind == 2001) continue;
        if (ind == 2000) {
            puts("NO");
            exit(0);
        }
        assert(ind < 2 * n);
        if (ind % 2 == 0)
            tmp[ind / 2] += 2 * b[i][2000];
        else
            tmp[ind / 2] += b[i][2000];
    }
    puts("YES");
    FOR(i, n)
    {
        if (tmp[i] == 3)
            putchar('B');
        else if (tmp[i] == 2)
            putchar('R');
        else if (tmp[i] == 1)
            putchar('Y');
        else
            putchar('.');
    }
    puts("");
}
```
