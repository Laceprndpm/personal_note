---
title: 【模板】原根
date: 2025-08-13
last_clear: 2025-08-13
tags:
  - tag/math/原根
  - tag/math/筛法
  - summary/原根
grasp: 3
difficulty: 2000
source: https://www.luogu.com.cn/problem/P6091
article: https://www.luogu.com.cn/problem/solution/P6091
---
### 定理（原根存在定理）
只有 $m = 2, 4, p^a, 2p^a$ 存在原根
暴力判断即
$g$ 为正整数，且$(g, m) = 1$ 。则 $g$ 是 $m$ 的原根当且仅当对于任意 $\varphi(m)$ 的质因子 $q_i$ 
$$
g^{\frac{\varphi(m)}{q_i}} \not\equiv 1 \pmod{m}  
$$

暴力寻找最小原根，一般来说，最小原根在 $m^{\frac{1}{4}}$ 范围内。
随后，可以构造所有原根而不是暴力筛
具体的，如果得到了某一原根，若对原根 $g$ 的指数 $k$ 满足 $gcd⁡(k,φ(n))=1 ,$，指数幂 $g^k$ 仍然是原根。
可以从指标（或阶）出发。
注意条件，有时候和 $m$ 互质，有时又是与 $\varphi(m)$ 互质

```c++
void solve()
{
    int n, d;
    cin >> n >> d;
    int phi = p.phi[n];
    if (!p.b[n]) {
        cout << 0 << '\n';
        cout << '\n';
        return;
    }
    vector<int> ds;
    {
        int ps = phi;
        while (ps > 1) {
            int curp = p.minp[ps];
            ds.pb(p.minp[ps]);
            while (p.minp[ps] == curp) ps = ps / curp;
        }
    }
    vector<int> ans;
    vector<int> bad(phi);
    for (int i : ds) {
        for (int j = i; j < phi; j += i) {
            bad[j] = 1;
        }
    }
    int g = -1;
    for (int i = 1; i < n; i++) {
        if (__gcd(i, n) != 1) continue;
        for (int dx : ds) {
            if (qpow(i, phi / dx, n) == 1) goto ed;
        }
        g = i;
        break;
    ed:
    }
    assert(g != -1);
    ans.pb(g);
    for (int i = 2; i < phi; i++) {
        if (!bad[i]) ans.pb(qpow(g, i, n));
    }
    sor(ans);
    cout << sz(ans) << '\n';
    for (int i = d - 1; i < sz(ans); i += d) {
        cout << ans[i] << ' ';
    }
    cout << '\n';
}
```
