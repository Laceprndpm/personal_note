---
title: D. Fuzzy Search
date: 2025-08-14
last_clear: 2025-08-14
tags:
  - tag/math/fftntt
  - tag/bitset
grasp: 1
difficulty: 2500
source: https://codeforces.com/contest/528/problem/D
article: https://codeforces.com/blog/entry/17020
---
# 形式化题意
给定两个字符串 $S$ 和 $T$，其中  
- $S$ 的长度为 $n$  
- $T$ 的长度为 $m$  
- 两者均由字符集 $\{\texttt{A}, \texttt{G}, \texttt{C}, \texttt{T}\}$ 构成  
- 另给定一个非负整数 $k$

定义：字符串 $T$ 可以与 $S$ 在位置 $p$ 匹配（$1 \le p \le n - m + 1$），当且仅当对于所有 $1 \le i \le m$，字符 $T_i$ 至少在 $S_{p+i-1-k}$ 到 $S_{p+i-1+k}$ 的范围内出现过（下标越界的部分忽略）。

任务：计算并输出所有满足上述条件的匹配起始位置的数量。
$$
(1 \le m \le n \le 2 \times 10^{5}, \ 0\le k \le2 \times 10^{5})
$$

# Solution
## StdSolution
本题存在一些问题。原本设定的约束条件是 $n, m, k \leq 500000$，预期解法是使用快速傅里叶变换（FFT），其能在该范围内保证运行时间。但不幸的是，题面中给出了错误的约束条件，因此在比赛过程中我们缩小了输入规模。不过，我们会在之后添加这个题目的更高难度版本，届时你将可以提交。
核心思想是将本题转化为多项式乘法。解题步骤如下：对于串 $S$ 的每一个位置 $i$，以及每一个字符 $c \in \{\text{A}, \text{T}, \text{G}, \text{C}\}$，我们计算 $\text{match}(c, i)$，其含义是：当将串 $T$ 放在位置 $i$ 时，与 $S$ 对应位置字符相同的 $c$ 的个数。若  
$$
\text{match}(\text{A}, i) + \text{match}(\text{T}, i) + \text{match}(\text{G}, i) + \text{match}(\text{C}, i) = |T|
$$ 
则说明串 $T$ 从位置 $i$ 开始恰好与 $S$ 的对应部分完全匹配。

接下来，我们来计算 $\text{match}(c, i)$。首先，在 $S$ 和 $T$ 中仅保留字符 $c$，其余字符记作“非 $c$”，并将它们分别用 $1$ 和 $0$ 表示。然后，在 $S$ 中，将每个 $1$ 向左、向右各延伸 $k$ 个位置。例如，对于样例串 `AGCAATTCAT` 且 $k = 1$，字符 A 的对应比特向量为 `111110111`，字符 C 的对应比特向量为 `0111001110`。这种比特向量可在 $O(n)$ 内求出：对原始 $S$ 中的每个 $1$，在位置 $x-k$ 添加一个“+1”事件，在位置 $x+k$ 添加一个“-1”事件，然后自左向右扫描整个串 $S$ 并处理这些事件。

此时，问题转化为：寻找所有位置，使得比特向量 $T$ 是比特向量 $S$ 的子掩码。在约束 $n, m, k \leq 200000$ 下，可用 bitset 在  
$$
O\big( m(n-m) / 32 \big)
$$  
时间内完成。然而，这个问题也可以视作求多项式 $S$ 与反转后的 $T$ 的卷积积。我们将此部分留作习题，供想要提交高难度版本的选手自行实现。
## 卷积(NTT)
若求匹配，且字符种类少，则可以逐字符匹配。
$$
\begin{align}
S(x) = \sum_{i = 1}^{n} [S_{string}[i] = \text{'A'}]x^i \\
T(x) = \sum_{i = 1}^{n} [T_{string}[i] = \text{'A'}]x^i
\end{align}
$$

随后

$$
\begin{align}
F(x) &= \text{rev}(S(x)) \cdot T(x) \\
a_i &= \sum_{l = 1,\ r = i - l}^{|T|} \left[S_{string}^{rev}[r] = T_{string}[l]\right] \\
&= \sum_{l = 1}^{|T|} \left[S_{string}[n + 1 - i + l] = T_{string}[l]\right] \\
&= \sum_{l = 1}^{|T|} \left[S_{string}[n - i + l] = T_{string}[l]\right]
\end{align}
$$
所以n - i 就是偏移量
表示往后推n - i 个再开始匹配
j = n - i
$0=<n - i<n$
$0<i<=n$

## 以下为原本笔记里的内容
$a_i$ 就是 $n + 2 - i$ 的开头。
$n + 2 - i = j$
$i = n + 2 - j$
$a_{n + 2 - j} = s[j]$ 

$$
F(x) = S(x) \cdot rev(T(x))
$$
$$
a_i = \sum_{l = 1, r = i - l}^{|T|} [S[l] = T^{rev}[r]]
$$
$$
a_i = \sum {S[l] = }
$$
这告诉我们不要试图用rev(T)，很难推
$$
= \sum_{l = 1}^{|T|} \left[S_{string}[n - i + l] = T_{string}[l]\right]
$$
## Bitset
和ntt一样的方法构造出不同字符的bitset后，不要逐一处理。
对于模式串来说，i位为A，那么若k位可以作为开头，则s>>i也的为A
详情参照代码
## Z函数
在评论区发现了Z函数解法
https://codeforces.com/blog/entry/17020
# Code
## NTT
```cpp showLineNubers title="lace.cpp"
void solve()
{
    int slen, tlen, k;
    cin >> slen >> tlen >> k;
    string s;
    cin >> s;
    s = ' ' + s;
    string t;
    cin >> t;
    t = ' ' + t;
    vector<int> ans(slen + 1);
    auto        work = [&](char c) {
        vector<Z> svec(8e5 + 50);
        for (int i = 1; i <= slen; i++) {
            if (s[i] == c) {
                svec[max(i - k, 1)] += 1;
                svec[min(i + k + 1, slen + 1)] -= 1;
            }
        }
        for (int i = 2; i <= slen; i++) {
            svec[i] += svec[i - 1];
        }
        for (int i = 1; i <= slen; i++) {
            if (svec[i].val()) {
                svec[i] = 1;
            }
        }
        reverse(svec.begin(), svec.begin() + 1 + slen);
        vector<Z> tvec(8e5 + 50);
        for (int i = 1; i <= tlen; i++) {
            if (t[i] == c) {
                tvec[i] = 1;
            }
        }
        convolution(svec.data(), tvec.data(), slen + tlen + 1);
        tvec = {};
        for (int j = 0; j < slen; j++) {
            int i = slen - j;
            ans[j] += svec[i].val();
        }
    };
    vector<char> cvec = {'A', 'T', 'C', 'G'};
    for (int i = 0; i < 4; i++) {
        work(cvec[i]);
    }
    int anscnt = 0;
    for (int i = 0; i < slen; i++) {
        if (ans[i] == tlen) {
            anscnt++;
        }
    }
    cout << anscnt << '\n';
}

```
## Bitset
```c++
#include <bits/stdc++.h>
#define N 200002
using namespace std;
int       n, m, k, s[N][4], c[501];
bitset<N> b[4], ans;
char      A[N], B[N];

signed main(void)
{
    int i, j;
    scanf("%d%d%d%s%s", &n, &m, &k, A + 1, B + 1), c['A'] = 0, c['G'] = 1, c['C'] = 2, c['T'] = 3;
    for (i = 1; i <= n; ++i) ++s[max(1, i - k)][c[A[i]]], --s[min(n + 1, i + k + 1)][c[A[i]]];
    for (i = 1; i <= n; ++i) {
        for (ans[i] = 1, j = 0; j < 4; ++j) {
            s[i][j] += s[i - 1][j];
            if (s[i][j]) b[j][i] = 1;
        }
    }
    // 对于模式串来说，i位为A，那么若k位可以作为开头，则s>>i也的为A
    for (i = 1; i <= m; ++i) ans &= (b[c[B[i]]] >> (i - 1));
    printf("%d\n", ans.count());
    return 0;
}
```
