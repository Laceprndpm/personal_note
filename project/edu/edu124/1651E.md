---
title: E. Sum of Matchings
date: 2025-11-26
last_clear: 2025-11-26
tags:
  - edu
  - tag/图论/二分图
  - tag/图论/特殊图
grasp: 0
value: 4
difficulty: 2600
optional_difficulty:
source: https://codeforces.com/contest/1651/problem/E
article:
---
- 引理一，匹配数总和为匹配中顶点数的一半。
- 引理二，划分中的长度为偶数的环或路径，所有的点都在匹配中。而长为奇的  
    路径会少一个点。
- 那么，思路为计算：划分数乘总点数(1)，减不在划分中的点(2)，减在划分中的长度奇  
    数的路径数(3)。
- 划分数(1)，即C(n,2)组合数的平方。
- 不在划分中(2)。对于每个点，即C(n,2)乘，C(i,2)及C(n-i-1,2)的和。i为0至  
    n-1。
- 引理三，二分图中，划分中长度奇数的路径，记中心为p。有两端l,r同顶点p  
    共在划分内；有L,R分别与l,r相连，远离p，且不在划分中。此时在此划分中  
    此路径符合引理二后一种情况。
- 那么，中心p对满足包含{l, ..., p, ..., r}不含L,R的划分贡献负一的点数。  
    枚举中心p按此计算即得思路中最后的部分(3)。Q.E.D.
作者：lifeich1  
链接：https://www.jianshu.com/p/9bfbc1a006bd  
来源：简书  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
所以简单地说，就是用 所有点数-未匹配点。
```cpp showLineNumbers
#include <bits/stdc++.h>

using namespace std;

const int N = 3043;

vector<int> g[2 * N];
int         n;
int         used[2 * N];

int choose2(int n) { return n * (n + 1) / 2; }

int count_ways(int L, int R, const vector<int>& forbidden)
{
    // 没有必须包含的点
    // 只有 forbidden 点 → 计算合法区间数量 = 三段的组合数之和
    if (L > R) {
        int ml = *min_element(forbidden.begin(), forbidden.end());
        int mr = *max_element(forbidden.begin(), forbidden.end());
        return choose2(ml) + choose2(mr - ml - 1) + choose2(n - 1 - mr);
    }
    // /遍历 forbidden 点调整左/右端点可选范围
    // 计算合法区间长度
    // 返回 合法区间数量
    // 核心是：数学上数有多少段 [l,r] 覆盖必须点、又不覆盖禁止点。O(1) 解决。
    int minl = 0;
    int maxl = L;
    int minr = R;
    int maxr = n - 1;
    for (auto x : forbidden) {
        if (L <= x && x <= R)
            return 0;
        else if (x < L)
            minl = max(minl, x + 1);
        else
            maxr = min(maxr, x - 1);
    }
    return (maxl - minl + 1) * (maxr - minr + 1);
}

vector<int> cur;

void dfs(int x)
{
    if (used[x] == 1) return;
    used[x] = 1;
    cur.push_back(x);
    for (auto y : g[x]) dfs(y);
}

long long calc(const vector<int>& cycle)
{
    int       m   = cycle.size();
    int       k   = m / 2;
    long long ans = 0;
    for (int i = 0; i < m; i++) {
        int z = cycle[i];
        if (z >= n) z -= n;
        ans += choose2(n) * 1ll * (choose2(z) + 0ll + choose2(n - z - 1));
        int l = n - 1, r = 0, L = n - 1, R = 0;
        int pl = i, pr = i;
        for (int j = 0; j < k; j++) {
            for (auto x : vector<int>({cycle[pl], cycle[pr]})) {
                if (x < n) {
                    l = min(l, x);
                    r = max(r, x);
                } else {
                    L = min(L, x - n);
                    R = max(R, x - n);
                }
            }
            vector<int> f, F;
            pl--;
            if (pl < 0) pl += m;
            pr++;
            if (pr >= m) pr -= m;
            for (auto x : vector<int>({cycle[pl], cycle[pr]})) {
                if (x < n)
                    f.push_back(x);
                else
                    F.push_back(x - n);
            }
            long long add = count_ways(l, r, f) * 1ll * count_ways(L, R, F);
            ans += add;
        }
    }
    return ans;
}

int main()
{
    cin >> n;
    for (int i = 0; i < 2 * n; i++) {
        int x, y;
        cin >> x >> y;
        --x;
        --y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    long long ans = n * 1ll * choose2(n) * 1ll * choose2(n) * 2ll;
    for (int i = 0; i < n; i++) {
        if (used[i]) continue;
        dfs(i);
        vector<int> cycle = cur;
        ans -= calc(cycle);
        cur = vector<int>();
    }
    cout << ans / 2 << endl;
}
```