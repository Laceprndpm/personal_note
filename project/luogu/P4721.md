---
title: 【模板】分治 FFT
date: 2025-05-01
last_clear: 2025-11-22
tags:
  - luogu
  - 模板
  - tag/math/分治fft
  - tag/分治/cdq分治
grasp: 3
value: 4
difficulty:
optional_difficulty: 省选/NOI−
source: https://www.luogu.com.cn/problem/P4721
article: https://zhuanlan.zhihu.com/p/664171207
---
# 题意
# P4721 【模板】分治 FFT
## 题目背景
也可用多项式求逆解决。
## 题目描述
给定序列 $g_{1\dots n - 1}$，求序列 $f_{0\dots n - 1}$。
其中 $f_i=\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。
答案对 $998244353$ 取模。
## 输入格式
第一行一个整数 $n$ 。
第二行 $n-1$ 个整数 $g_{1\dots n - 1}$。
## 输出格式
一行 $n$ 个整数，表示 $f_{0\dots n - 1}$ 对 $998244353$ 取模后的值。
## 输入输出样例 #1
### 输入 #1
```
4
3 1 2
```
### 输出 #1
```
1 3 10 35
```
## 输入输出样例 #2
### 输入 #2
```
10
2 456 32 13524543 998244352 0 1231 634544 51
```
### 输出 #2
```
1 2 460 1864 13738095 55389979 617768468 234028967 673827961 708520894
```
## 说明/提示
$2\leq n\leq 10^5$，$0\leq g_i<998244353$。
# Solution
本质是CDQ分治，
```cpp showLineNumbers
Z g = 3;

/*
 * 进行 FFT 和 IFFT 前的反置变换
 * 位置 i 和 i 的二进制反转后的位置互换
 * len 必须为 2 的幂
 */
void change(Z y[], int len)
{
    // 一开始 i 是 0...01，而 j 是 10...0，在二进制下相反对称。
    // 之后 i 逐渐加一，而 j 依然维持着和 i 相反对称，一直到 i = 1...11。
    for (int i = 1, j = len / 2, k; i < len - 1; i++) {
        // 交换互为小标反转的元素，i < j 保证交换一次
        if (i < j) swap(y[i], y[j]);
        // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的。
        // 这里 k 代表了 0 出现的最高位。j 先减去高位的全为 1 的数字，直到遇到了
        // 0，之后再加上即可。
        k = len / 2;
        while (j >= k) {
            j = j - k;
            k = k / 2;
        }
        if (j < k) j += k;
    }
}

void ntt(Z y[], int len, int on)
{
    // 位逆序置换
    change(y, len);
    // 模拟合并过程，一开始，从长度为一合并到长度为二，一直合并到长度为 len。
    for (int h = 2; h <= len; h <<= 1) {
        // wn：当前单位复根的间隔：w^1_h
        Z wn = power(g, (Z::mod() - 1) / h);
        if (on == -1) wn = wn.inv();
        // 合并，共 len / h 次。
        for (int j = 0; j < len; j += h) {
            // 计算当前单位复根，一开始是 1 = w^0_n，之后是以 wn 为间隔递增： w^1_n
            // ...
            Z w(1);
            for (int k = j; k < j + h / 2; k++) {
                // 左侧部分和右侧是子问题的解
                Z u = y[k];
                Z t = w * y[k + h / 2];
                // 这就是把两部分分治的结果加起来
                y[k]         = u + t;
                y[k + h / 2] = u - t;
                // 后半个 「step」 中的ω一定和 「前半个」 中的成相反数
                // 「红圈」上的点转一整圈「转回来」，转半圈正好转成相反数
                // 一个数相反数的平方与这个数自身的平方相等
                w = w * wn;
            }
        }
    }
    // 如果是 IDFT，它的逆矩阵的每一个元素不只是原元素取倒数，还要除以长度 len。
    if (on == -1) {
        for (int i = 0; i < len; i++) {
            y[i] /= len;
        }
    }
}

signed main(int argc, char **argv)

{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#ifdef BATCH
    freopen(argv[1], "r", stdin);
    freopen(argv[2], "w", stdout);
#endif
    int n;
    cin >> n;
    vector<Z> grr(n + 1);
    for (int i = 1; i < n; i++) {
        cin >> grr[i];
    }
    vector<Z> frr(n);
    int       len = 1;
    frr[0]        = 1;
    while (len < n * 2) {
        len <<= 1;
    }
    grr.resize(len), frr.resize(len);
    function<void(int, int)> cdqDFS = [&](int start, int curL) -> void {
        if (curL == 1) return;
        cdqDFS(start, curL / 2);
        vector<Z> temp_frr(frr.begin() + start, frr.begin() + start + curL / 2);
        vector<Z> temp_grr(grr.begin(), grr.begin() + curL);
        temp_frr.resize(curL), temp_grr.resize(curL);
        ntt(temp_frr.data(), curL, 1);
        ntt(temp_grr.data(), curL, 1);
        for (int i = 0; i < curL; i++) {
            temp_frr[i] *= temp_grr[i];
        }
        ntt(temp_frr.data(), curL, -1);
        for (int i = 0; i < curL / 2; i++) {
            frr[start + curL / 2 + i] += temp_frr[curL / 2 + i];
        }
        cdqDFS(start + curL / 2, curL / 2);
    };

    cdqDFS(0, len);
    for (int i = 0; i < n; i++) {
        cout << frr[i] << ' ';
    }
    return 0;
}
```