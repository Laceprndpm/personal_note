---
title: E. Limited Edition Shop
date: 2025-12-09
last_clear: 2025-12-09
tags:
  - div2
  - tag/数据结构/线段树
  - tag/dp
  - tag/排序
grasp: 4
value: 4
difficulty: 2100
optional_difficulty:
source: https://codeforces.com/contest/2151/problem/E
article:
---
```cpp showLineNumbers
void solve()
{
    // 如果bob买到了k，则b[0 - k-1]都被买了，被谁？
    // dp[k]为前k个都被买了的情况
    // dp[k] = dp[k - 1] + k买了后，解锁了的后面的东西的最高价值？
    // dp[k]为已经绕开了b[i]的前k个（包含）个选项，后续就不能再进入了
    int n;
    cin >> n;
    vector<i64> ai(n + 1);
    vector<int> aord(n + 1);
    vector<int> bord(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> ai[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> aord[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> bord[i];
    }
    {
        vector<i64> tmpai(n + 1);
        vector<int> remap(n + 1);
        vector<int> new2raw(n + 1);
        for (int i = 1; i <= n; i++) {
            new2raw[bord[i]] = i;
        }
        for (int i = 1; i <= n; i++) {
            tmpai[i] = ai[bord[i]];
            aord[i]  = new2raw[aord[i]];
        }
        ai = tmpai;
    }
    LazySegmentTree<Info, Tag> dp(n + 1, {-INF});
    dp.modify(0, {0});
    // dp[i]为已经跳过了前i个
    //
    for (int i = 1; i <= n; i++) {
        int cur = aord[i];
        int val = ai[cur];
        // 跳过这个，必须要让b不可逆地到cur
        auto res = dp.rangeQuery(0, cur);
        dp.modify(cur, Info{res});
        dp.rangeApply(0, cur, Tag{val});  // 所有没有放弃前缀的可以++
    }
    cout << dp.rangeQuery(0, n + 1).x << '\n';
}
```