---
title: Zero Trailing Factorial
date: 2025-10-11
last_clear: 2025-10-11
tags:
  - tag/math/数论
  - tag/细心
grasp: 2
value: 5
difficulty: 2300
optional_difficulty:
source: https://codeforces.com/contest/2153/problem/E
article:
---
非常可惜，一开始就认为只有 $p^n$ 是有效的 $k$ 但自己又给否了，理由是可能存在
$\min(a, b) != \min(c, d)$ 而又存在 $a > b$ 且 $c < d$ 的情况，但是既然 $a$ 是最小的，则 $a \le \min(a, b) < \min(c, d) \le c$ ，因此确确实实只有 $p^n$ 是有效的。
建议以后无论多么确定，思考一段时间后都要回顾一下注释，或者写下例子
```cpp
void solve()
{
    // 可以肯定，一定是p^i
    // 1e7，是不是让我预处理质数？ 664579
    // min(a, b) != min(c, d)
    // m >= n，感觉很关键
    // 哪些是0，如果n! = p1^a1 * p2^a2...
    // 可以构造p1^a1,p2^a2...让v(n!) = 1感觉很难，方向不对
    // 如果只考虑n，小于n的最大的质数设为p
    // 则1...p - 1的x!都是0
    // 153
    //
    // i64 ans = 0;
    // for (int n = 1; n <= 1e7; n++) {
    // ans = max(ans, ll(n) - *lower_bound(all(pprime.primes), n, greater<>()));
    // cout << ans << '\n';
    // 对153个做暴力吗?
    // 我一定会选择什么？n的约数吗？
    // 选p，则一定会1 = 1
    // 枚举m内的？
    // m | n?
    // 如何求v_k(n!) ?
    // 1e7 * 664579有点夸张
    // 如果k是合数，那么v_k = min(v_p1 , v_p2)
    // 如果是质数，则考虑该质数的次数，只需要考虑有多少个1次方，二次方。。。log级别
    //
    int n, m;
    cin >> n >> m;
    int         p0 = *lower_bound(all(prime.primes), n, greater<>());
    vector<int> candidate;
    for (int p = p0; p <= n; p++) {
        int vp = p;
        while (vp != 1) {
            candidate.pb(prime.minp[vp]);
            vp /= prime.minp[vp];
        }
    }
    sor(candidate);
    candidate.erase(unique(all(candidate)), candidate.end());

    auto fx = [&](int x, int p) -> i64 {
        i64 c = 0;
        while (x) {
            x /= p;
            c += x;
        }
        return c;
    };
    i64 ans = 0;
    for (int i = p0; i < n; i++) {
        i64 tmpans = INF;
        for (int p : candidate) {
            i64 valx = fx(i, p);
            i64 valn = fx(n, p);
            i64 vp   = p;
            int pow  = 1;
            while (vp <= m) {
                if (valx / pow != valn / pow) {
                    tmpans = min(tmpans, valx / pow);
                }
                vp *= p;
                pow++;
            }
        }
        ans += tmpans;
    }
    cout << ans << '\n';
}
```