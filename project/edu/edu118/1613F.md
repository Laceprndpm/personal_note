---
title: F. Tree Coloring
date: 2025-05-16
last_clear: 2025-11-22
tags:
  - edu
  - tag/计数/容斥
  - tag/计数/树上计数
grasp: 3
value: 5
difficulty: 2600
optional_difficulty:
source: https://codeforces.com/contest/1613/problem/F
article: https://codeforces.com/blog/entry/97467
---
# Solution
## Step1-容斥:
首先对这个满足某些条件的计数问题，转化成容斥问题，即记 `k` 为违反了 `k` 条及以上的约束，那么 
$$
ans = \sum_{k =0}^{n - 1}{(-1)}^{k}f(k)(n - k)!
$$
## Step2-dp:
只需要注意到，可以将每个边定向给一个父亲节点，就可以转化成
$$
\sum_{2}^{n}(1+d_i\cdot x)
$$
的形式，可以用分治ftt解决
```cpp showLineNumbers
void solve()
{
    int n;
    cin >> n;
    vector<vector<int>> adj(n + 1);
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].pb(v);
        adj[v].pb(u);
    }
    vector<int>  sons(n + 1);
    deque<PolyZ> dadntt;
    auto         dfs = [&](this auto &&self, int u, int fa) -> void {
        for (int v : adj[u]) {
            if (v == fa) continue;
            self(v, u);
            sons[u]++;
        }
        dadntt.pb({1, sons[u]});
    };
    dfs(1, 0);
    while (dadntt.size() > 1) {
        auto a = std::move(dadntt.front());
        dadntt.pop_front();
        auto b = std::move(dadntt.front());
        dadntt.pop_front();
        auto c = a * b;
        dadntt.pb(std::move(c));
    }
    Z    ans = 0;
    auto cur = dadntt.front();
    cur.resize(n);
    for (int i = 0; i < n; i++) {
        ans += ((i % 2 == 1) ? -1 : 1) * comb.fac(n - i) * cur[i];
    }
    cout << ans << '\n';
}
```
