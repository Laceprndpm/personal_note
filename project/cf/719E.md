---
title: E. Sasha and Array
date: 2025-08-06
last_clear: 2025-08-25
tags:
  - tag/dp/快速幂
grasp: 3
difficulty: 2300
source: https://codeforces.com/contest/719/problem/E
article:
---
# 题意：
一个整数数组 $a_1, a_2, \dots , a_n$ 。你必须执行 _m_ 次查询。可能有两种类型的查询：
1. `1 l r x` 对 `l` 到 `r` 段上的所有整数加 `x`；
2. `2 l r` -查找，$\sum_{l}^{r}f(x)$ 其中 $f(x)$ 是 第 $x -1$ 个斐波那契数字。
MOD = 1e9 + 7
# Solution
用 $2 \times 1$ 矩阵表示每个元素，可以用矩阵快速幂来加速
```c++
constexpr OMatrix<Z, 2, 2> dp = {{1, 1}, {1, 0}};
constexpr OMatrix<Z, 2, 1> one{{1}, {0}};
constexpr OMatrix<Z, 2, 2> basis{{1, 0}, {0, 1}};
 
auto get_fib(i64 x)
{
    if (x == 1) {
        return one;
    }
    auto res = power(dp, x - 1, basis);
    return res * one;
}
 
struct Tag {
    OMatrix<Z, 2, 2> x;
 
    Tag()
    {
        x = basis;
    }
 
    Tag(int _x)
    {
        x = power(dp, _x, basis);
    }
 
    void apply(const Tag &t) &
    {
        x = x * t.x;
    }
};
 
struct Info {
    OMatrix<Z, 2, 1> x;
 
    Info()
    {
        x = {{0}, {0}};
    }
 
    Info(int _x)
    {
        x = get_fib(_x);
    }
 
    Info(OMatrix<Z, 2, 1> _x)
    {
        x = _x;
    }
 
    void apply(const Tag &t) &
    {
        x = t.x * x;
    }
};
 
Info operator+(const Info &a, const Info &b)
{
    auto tmp = a.x;
    tmp += b.x;
    return {tmp};
}
 
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    LazySegmentTree<Info, Tag> seg(arr);
    while (m--) {
        int tp, l, r;
        cin >> tp >> l >> r;
        l--;
        if (tp == 1) {
            int x;
            cin >> x;
            seg.rangeApply(l, r, {x});
        } else {
            auto res = seg.rangeQuery(l, r);
            cout << res.x.data[0][0] << '\n';
        }
    }
}
```
Note：
弃用了起初的动态矩阵，改用静态数组，实测提高10倍以上速度
