---
title: " 三轮"
date: 2025-08-31
last_clear: 2025-08-31
tags:
  - tag/math/多项式和生成函数
grasp:
difficulty:
source: https://ac.nowcoder.com/acm/contest/157/F
article:
---
# 题意
小k有一个三轮，它最多可以装$10^5$大小的东西
小k有n种商品，他要准备出摊了
每种商品体积为$v_i$，都有$10^5$件
输出凑成 $1 \dots m$ 的体积的总方案数
输出可能会很大，请对大质数 `19260817` 取模 
# Solution
每种物品1e5个，就相当于$\infty$ 个，因此每件物品相当于
$$
f_i(x) = 1 + x^{v_i} + x^{2v_i} + \dots = \frac{1}{1 - x^{v_i}}
$$
最终方案数就是
$$
F(x) = \prod_{i = 1}^{n}f_i(x)
$$
记
$$
g(x) = \ln(F(x)) = \sum{\ln(\frac{1}{1 - x^{v_i}})} = \sum{-\ln(1 - x^{v_i})}
$$
而
$$
\ln(1 + x) = \sum_{i = 1}{(-1)^{i - 1} x^i \cdot \frac{1}{i}}
$$
则
$$
-\ln(1 - x) = x + \frac{x^2}{2} +\frac{x^3}{3} + \dots 
$$
那么就可以用计数的方法，$O(n \ln (n))$ 的复杂度求解$\sum{-\ln(1 - x^{v_i})}$

```c++
template <u32 P>
struct ntt_traits {
    static constexpr u32 g = 0;
};

template <>
struct ntt_traits<469762049> {
    static constexpr u32 g = 3;
};

template <>
struct ntt_traits<998244353> {
    static constexpr u32 g = 3;
};

template <>
struct ntt_traits<1004535809> {
    static constexpr u32 g = 3;
};

template <u32 P>
void ntt(vector<ModInt<P>> &y, int on)
{
    assert(ntt_traits<P>::g);
    constexpr MInt<P> g   = ntt_traits<P>::g;
    const int         len = y.size();
    assert((len == (len & -len)) && len);
    // 位逆序置换
    change(y);
    // 模拟合并过程，一开始，从长度为一合并到长度为二，一直合并到长度为 len。
    for (int h = 2; h <= len; h <<= 1) {
        // wn：当前单位复根的间隔：w^1_h
        assert(((P - 1) & (h - 1)) == 0);
        ModInt<P> wn = power(g, (P - 1) / h);
        if (on == -1) wn = wn.inv();
        // 合并，共 len / h 次。
        for (int j = 0; j < len; j += h) {
            // 计算当前单位复根，一开始是 1 = w^0_n，之后是以 wn 为间隔递增： w^1_n
            // ...
            ModInt<P> w(1);
            for (int k = j; k < j + h / 2; k++) {
                // 左侧部分和右侧是子问题的解
                ModInt<P> u = y[k];
                ModInt<P> t = w * y[k + h / 2];
                // 这就是把两部分分治的结果加起来
                y[k]         = u + t;
                y[k + h / 2] = u - t;
                // 后半个 「step」 中的ω一定和 「前半个」 中的成相反数
                // 「红圈」上的点转一整圈「转回来」，转半圈正好转成相反数
                // 一个数相反数的平方与这个数自身的平方相等
                w = w * wn;
            }
        }
    }
    // 如果是 IDFT，它的逆矩阵的每一个元素不只是原元素取倒数，还要除以长度 len。
    ModInt<P> iv = ModInt<P>(len).inv();
    if (on == -1) {
        for (int i = 0; i < len; i++) {
            y[i] = y[i] * iv;
        }
    }
}

template <u32 P>
vector<MInt<P>> convolution(vector<MInt<P>> const &x, vector<MInt<P>> const &y)
{
    assert(x.size() == y.size());
    const u32 n = x.size();
    assert((n & -n) == n);
    constexpr i64      M[3] = {469762049, 998244353, 1004535809};
    vector<MInt<M[0]>> v11(n), v12(n);
    vector<MInt<M[1]>> v21(n), v22(n);
    vector<MInt<M[2]>> v31(n), v32(n);
    memcpy(v11.data(), x.data(), n * sizeof(int));
    memcpy(v21.data(), x.data(), n * sizeof(int));
    memcpy(v31.data(), x.data(), n * sizeof(int));
    memcpy(v12.data(), y.data(), n * sizeof(int));
    memcpy(v22.data(), y.data(), n * sizeof(int));
    memcpy(v32.data(), y.data(), n * sizeof(int));
    ntt(v11, 1), ntt(v12, 1);
    ntt(v21, 1), ntt(v22, 1);
    ntt(v31, 1), ntt(v32, 1);
    for (int i = 0; i < n; i++) {
        v11[i] *= v12[i];
        v21[i] *= v22[i];
        v31[i] *= v32[i];
    }
    ntt(v11, -1);
    ntt(v21, -1);
    ntt(v31, -1);
    constexpr i128  multi = i128(M[0]) * M[1] * M[2];
    constexpr i128  m0    = multi / M[0];
    constexpr i128  m1    = multi / M[1];
    constexpr i128  m2    = multi / M[2];
    vector<MInt<P>> res(n);
    for (int i = 0; i < n; i++) {
        constexpr i128 c0 = m0 * CInv<u32(m0 % M[0]), u32(M[0])>.val();
        constexpr i128 c1 = m1 * CInv<u32(m1 % M[1]), u32(M[1])>.val();
        constexpr i128 c2 = m2 * CInv<u32(m2 % M[2]), u32(M[2])>.val();
        res[i]            = u32((c0 * v11[i].val() + c1 * v21[i].val() + c2 * v31[i].val()) % multi % P);
    }
    return res;
}
...
    constexpr friend Poly operator*(Poly a, Poly b)
    {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        if (a.size() < b.size()) {
            swap(a, b);
        }
        int n = 1, tot = a.size() + b.size() - 1;
        while (n < tot) {
            n *= 2;
        }
        // if (((P - 1) & (n - 1)) != 0 || b.size() < 128) {
        //     Poly c(a.size() + b.size() - 1);
        //     for (int i = 0; i < a.size(); i++) {
        //         for (int j = 0; j < b.size(); j++) {
        //             c[i + j] += a[i] * b[j];
        //         }
        //     }
        //     return c;
        // }
        a.resize(n);
        b.resize(n);
        // dft(a);
        // dft(b);
        // for (int i = 0; i < n; ++i) {
        //     a[i] *= b[i];
        // }
        // idft(a);
        auto res = convolution(a, b);
        res.resize(tot);
        return Poly{res};
    }
    
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> vi(n);
    vector<int> cnt(m + 1);
    vector<Z>   invvec(m + 1);
    invvec[1] = 1;
    for (int i = 2; i <= m; i++) {
        invvec[i] = -invvec[P % i] * (P / i);
    }
    for (int i = 0; i < n; i++) {
        cin >> vi[i];
        if (vi[i] <= m) cnt[vi[i]]++;
    }
    PolyZ poly(m + 1);
    for (int i = 1; i <= m; i++) {
        for (int j = 1, val = i; val <= m; j++, val += i) {
            poly[val] += cnt[i] * invvec[j];
        }
    }
    auto fx  = poly.exp(m + 1);
    Z    ans = 0;
    for (int i = 1; i <= m; i++) {
        ans += fx[i];
    }
    cout << ans << '\n';
}
```
