---
title: E. Crazy Robot
date: 2025-04-24
last_clear: 2025-11-25
tags:
  - edu
  - tag/bfs
grasp: 3
value: 4
difficulty: 2000
optional_difficulty:
source: https://codeforces.com/contest/1613/problem/E
article:
---
当且仅当周围有路径被更新时才需要考虑更新自身。
也当且仅当周围所有路都被堵死时才会被纳入 `+` 的联通快。
同时由于方向随机，所以只要他的路径能在只有 `.` 的块里强联通也不需要考虑，所以这样bfs就行，复杂度约为 $\mathcal{O}(4n)$ 
```cpp showLineNumbers
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<string> bd(n + 2);
    for (int i = 1; i <= n; i++) {
        cin >> bd[i];
        bd[i] = '#' + bd[i] + '#';
    }
    bd[0] = bd[n + 1] = string(m + 2, '#');
    deque<i64>                    que;
    function<i64(i64 x, i64 y)>   zip   = [&](i64 x, i64 y) -> i64 { return x * (m + 2) + y; };
    function<pair<i64, i64>(i64)> unzip = [&](i64 x) -> pair<i64, i64> { return {x / (m + 2), x % (m + 2)}; };
    for (int i = 0; i < n + 2; i++) {
        for (int j = 0; j < m + 2; j++) {
            if (bd[i][j] == 'L') {
                que.push_back(zip(i, j));
            }
        }
    }
    int mx[] = {0, 0, -1, 1};
    int my[] = {1, -1, 0, 0};
    while (!que.empty()) {
        i64 top = que.front();
        que.pop_front();
        auto [x, y] = unzip(top);
        if (bd[x][y] == 'L') {
            for (int i = 0; i < 4; i++) {
                int nx = x + mx[i], ny = y + my[i];
                if (bd[nx][ny] == '.') {
                    que.push_back(zip(nx, ny));
                }
            }
        } else {
            int cnt = 0;
            for (int i = 0; i < 4; i++) {
                int nx = x + mx[i], ny = y + my[i];
                if (bd[nx][ny] == '.') {
                    cnt++;
                }
            }
            if (cnt <= 1) {
                bd[x][y] = '+';
                for (int i = 0; i < 4; i++) {
                    int nx = x + mx[i], ny = y + my[i];
                    if (bd[nx][ny] == '.') {
                        que.push_back(zip(nx, ny));
                    }
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cout << bd[i][j];
        }
        cout << '\n';
    }
}
```
