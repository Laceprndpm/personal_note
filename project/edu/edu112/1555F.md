---
title: F. Good Graph
date: 2025-11-11
last_clear: 2025-11-11
tags:
  - edu
  - tag/dsu
  - tag/图论/树上问题
  - tag/图论/树上问题/树上差分和前缀和
  - tag/数据结构/树状数组
grasp:
value: 5
difficulty:
optional_difficulty: Easy
source: https://codeforces.com/contest/1555/problem/F
article:
---
见题解
总之还是和树有关，而不是真正的环
```cpp showLineNumbers
void solve()
{
    int n, q;
    cin >> n >> q;
    DSU                            dsu(n + 1);
    vector<vector<pair<int, int>>> adj(n + 1);
    vector<int>                    par(n + 1);
    vector<int>                    pathxor(n + 1);
    vector<array<int, 20>>         mupar(n + 1);
    int                            cnt = 0;
    vector<int>                    in(n + 1), out(n + 1);
    vector<int>                    dep(n + 1);
    auto                           initlca = [&](void) {
        for (int u = 1; u <= n; u++) {
            mupar[u][0] = par[u];
        }
        for (int i = 1; i < 20; i++) {
            for (int j = 1; j <= n; j++) {
                mupar[j][i] = mupar[mupar[j][i - 1]][i - 1];
            }
        }
    };
    auto lca = [&](int u, int v) {
        if (dep[u] < dep[v]) {
            swap(u, v);
        }
        for (int i = 19; i >= 0; i--) {
            if (dep[mupar[u][i]] >= dep[v]) {
                u = mupar[u][i];
            }
        }
        if (u == v) return u;
        for (int i = 19; i >= 0; i--) {
            if (mupar[u][i] != mupar[v][i]) {
                u = mupar[u][i];
                v = mupar[v][i];
            }
        }
        return par[u];
    };

    auto dfs = [&](this auto&& self, int u, int fa) -> void {
        in[u] = ++cnt;
        for (auto [v, w] : adj[u]) {
            if (v == fa) continue;
            par[v]     = u;
            dep[v]     = dep[u] + 1;
            pathxor[v] = pathxor[u] ^ w;
            self(v, u);
        }
        out[u] = cnt;
    };
    vector<int>           ans(q);
    vector<int>           tocheck;
    vector<array<int, 3>> query(q);
    for (int i = 0; i < q; i++) {
        int u, v, x;
        cin >> u >> v >> x;
        query[i] = {u, v, x};
        if (!dsu.same(u, v)) {
            adj[u].pb({v, x});
            adj[v].pb({u, x});
            dsu.merge(u, v);
            ans[i] = 1;
        } else {
            tocheck.pb(i);
        }
    }
    vector<Fenwick<int>> fk(n + 1);
    for (int i = 1; i <= n; i++) {
        if (i == dsu.find(i)) {
            cnt    = 0;
            fk[i]  = Fenwick<int>(dsu.size(i) + 2);
            par[i] = i;
            dep[i] = 1;
            dfs(i, 0);
        }
    }
    initlca();
    auto ad = [&](int root, int u, int v) -> void {
        if (dep[u] < dep[v]) {
            swap(u, v);
        }
        while (dep[u] != dep[v]) {
            fk[root].add(in[u], 1);
            fk[root].add(out[u] + 1, -1);
            u = par[u];
        }
        while (u != v) {
            fk[root].add(in[u], 1);
            fk[root].add(out[u] + 1, -1);
            fk[root].add(in[v], 1);
            fk[root].add(out[v] + 1, -1);
            u = par[u], v = par[v];
        }
        return;
    };
    for (int i : tocheck) {
        auto [u, v, x] = query[i];
        int root       = dsu.find(u);
        if ((pathxor[u] ^ pathxor[v] ^ x) != 1) continue;
        // cout << fk[root].sum(in[u] + 1) + fk[root].sum(in[v] + 1) - 2 * fk[root].sum(in[lca(u, v)] + 1) << endl;
        if (fk[root].sum(in[u] + 1) + fk[root].sum(in[v] + 1) - 2 * fk[root].sum(in[lca(u, v)] + 1) != 0) continue;
        ad(root, u, v);
        ans[i] = 1;
    }
    for (int i = 0; i < q; i++) {
        cout << (ans[i] ? "Yes\n" : "No\n");
    }
}
```
