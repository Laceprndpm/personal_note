## 构造:
对一个排列 `a[0..n-1]`，其下一个排列按如下规则构造：
### 步骤（算法流程）：
> 假设当前序列为：`a = [1, 3, 5, 4, 2]`
1. **从后往前找第一个 `i`，满足 `a[i] < a[i+1]`：**
    - 这是“下降转折点”，我们称之为“第一对逆序”。
    - 上例中：`i = 1`，因为 `a[1] = 3 < 5 = a[2]`。
    - 若找不到这样的 `i`，说明当前是最大排列，返回 `false`。
2. **从后往前找第一个 `j`，满足 `a[j] > a[i]`：**
    - 因为我们要找到最小的比 `a[i]` 大的数，替换掉 `a[i]`。
    - 上例中：`j = 4`，`a[4] = 2` 不满足；`j = 3`，`a[3] = 4 > 3`，满足。
3. **交换 `a[i]` 与 `a[j]`：**
    - 使得前缀更大，但要保证仍是最小的大。
    - 上例中：交换 `a[1]` 和 `a[3]`，得到 `[1, 4, 5, 3, 2]`
4. **将 `a[i+1..n-1]` 反转（reverse）：**
    - 因为后缀是递减的，要变成递增才能成为“下一个最小排列”。
    - 上例中，反转 `[5,3,2]` 变为 `[2,3,5]`，最终得到 `[1, 4, 2, 3, 5]`。
```c++
// _GLIBCXX20
template<typename BidIt, typename Compare>
bool next_permutation(BidIt first, BidIt last, Compare comp) {
    if (first == last) return false;
    BidIt i = last;
    if (first == --i) return false;

    while (true) {
        BidIt i1 = i;
        if (comp(*--i, *i1)) {
            BidIt j = last;
            while (!comp(*i, *--j)) {}
            std::iter_swap(i, j);
            std::reverse(i1, last);
            return true;
        }
        if (i == first) {
            std::reverse(first, last);
            return false;
        }
    }
}
```
### 算法流程（构造上一个排列）
假设当前序列为：`a = [1, 3, 5, 4, 2]`
1. **从后往前找第一个 `i`，满足 `a[i] > a[i+1]`：**
    - 这是“上升转折点”（对 next 的下降点取反）。
    - 上例中：`i = 2`，因为 `a[2] = 5 > 4 = a[3]`。
    - 如果找不到这样的 `i`，说明当前序列已经是最小排列（严格递增），返回 `false`。
2. **从后往前找第一个 `j`，满足 `a[j] < a[i]`：**
    - 因为要找到最接近 `a[i]` 且比它小的数。
    - 上例中：检查：`a[4] = 2 < 5`，满足，所以 `j = 4`。
3. **交换 `a[i]` 与 `a[j]`：**
    - 上例中：交换 `a[2]` 和 `a[4]`，得到 `[1, 3, 2, 4, 5]`。
4. **将 `a[i+1..n-1]` 反转：**
    - 后缀原本是递增的，要变成递减，才能保证是**最大的小排列**。
    - 上例中：后缀 `[4,5]` 反转为 `[5,4]`，最终得到 `[1, 3, 2, 5, 4]`。
```c++
// _GLIBCXX20
template<typename BidIt, typename Compare>
bool prev_permutation(BidIt first, BidIt last, Compare comp) {
    if (first == last) return false;       // 空区间
    BidIt i = last;
    if (first == --i) return false;        // 只有一个元素

    while (true) {
        BidIt i1 = i;                      // i1 指向当前后继
        if (comp(*i1, *--i)) {             // 找到第一个满足 a[i] > a[i+1] 的位置
            BidIt j = last;
            while (!comp(*--j, *i)) {}     // 找到右侧第一个比 a[i] 小的元素
            std::iter_swap(i, j);          // 交换
            std::reverse(i1, last);        // 翻转后缀
            return true;                   // 成功找到上一个排列
        }
        if (i == first) {
            std::reverse(first, last);     // 已经是最小排列，翻转为最大排列
            return false;
        }
    }
}
```
