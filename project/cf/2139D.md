---
title: D. Antiamuny Wants to Learn Swap
date: 2025-09-08
last_clear: 2025-09-09
tags:
  - tag/thinking
  - tag/扫描线
  - tag/ST表
  - tag/单调栈
grasp: 3
value: 5
difficulty: 1600
optional_difficulty:
source: https://codeforces.com/contest/2139/problem/D
article:
---
# 前言
## thinking
注意**分开**观察你所选结论的**必要性和充分性**，如果长时间WA要想想看是不是结论错了
## 数据结构
对扫描线的理解程度增加了，但实际上用ST表记录每个线段的右端点的最小值即可
# 题意
However, you can only perform operation 2 .For an array $b$ of length $m$, you may perform the following two operations: 1. Select an index $1\le i\le m - 1$. Then, swap the values of $b_i$ and $b_{i + 1}$. 2. Select an index $1\le i\le m - 2$. Then, swap the values of $b_i$ and $b_{i + 2}$. However, you can only perform operation $2$ **at most once**. We define $f(b)$ as the minimum number of operations (using both operation 1 and operation 2) required to sort array $b$ in non-decreasing order, and $g(b)$ as the minimum number of operations required to sort array $b$ in non-decreasing order **using only operation 1**. The array $b$ is perfect if $f(b) = g(b)$. In other words, the ability to use operation 2 does not reduce the number of operations required to sort array $b$ compared to using only adjacent swaps. You are given a permutation $a$ of length $n$$^{\text{∗}}$, and must answer $q$ queries. Each query consists of two integers $l$ and $r$ ($1\le l\le r\le n$), representing the subarray $a[l\ldots r]$$^{\text{†}}$. For each query, determine whether the subarray $a[l\ldots r]$ is perfect. $^{\text{∗}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array). $^{\text{†}}$The subarray $a[l\ldots r]$ includes all elements from index $l$ to $r$, i.e., $[a_l, a_{l + 1}, a_{l + 2}, \ldots, a_r]$.
## Input
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 5 \cdot 10^4$). The description of the test cases follows. The first line of each test case contains two integers $n$, $q$ ($1 \le n, q \le 5 \cdot 10^5$) — the length of array $a$ and the number of queries. The second line of each test case contains $n$ integers $a_1, a_2, \ldots ,a_n$ ($1 \le a_i \le n$) — the elements in permutation $a$. Each of the next $q$ lines contains two integers $l$ and $r$ ($1 \leq l \leq r \leq n$) — the left and right endpoints of the queried subarray. It is guaranteed that both the sum of $n$ and the sum of $q$ over all test cases do not exceed $5\cdot 10^5$.
## Output 
For each test case, output "YES" if queried subarray $a[l\ldots r]$ is perfect, and "NO" otherwise.
# Solution
## std
对于数组 $b$，我们可以证明：  
当且仅当存在下标 $1\le i<j<k\le m$ 且满足 $b_i>b_j>b_k$ 时，$f(b)\neq g(b)$。
由于 $a$ 是一个排列，因此 $b$ 中的所有元素都应当互不相同。  
$g(b)$ 等于 $b$ 中的逆序对个数。  
当存在某个下标 $i$ 满足 $a_i>a_{i+1}>a_{i+2}$ 时，我们可以通过一次操作 $2$ 将逆序对数减少 $3$，从而使得 $f(b)$ 小于 $g(b)$。这是唯一一种可以在一次操作中消除超过 $1$ 个逆序对的情况。
如果存在下标 $1\le i<j<k\le m$ 且满足 $b_i>b_j>b_k$，我们可以先选择下标 $i,k$，然后通过交换相邻数字（即执行操作 $1$），把所有大于 $b_i$ 的元素移到 $b_k$ 的右边，把所有小于 $b_k$ 的元素移到 $b_i$ 的左边。  
此时在 $b_i,b_k$ 之间的所有元素 $b_p$ 都满足 $b_i>b_p>b_k$。  
接下来我们不断将它们交换到 $b_i$ 的左侧，直到只剩下一个元素 $b_j$。  
此时有 $b_i>b_j>b_k$ 且它们相邻，就可以在 $b_i$ 当前位置执行操作 $2$。
如果我们只在满足 $b_i>b_{i+1}$ 的下标上执行操作 $1$，那么在过程中永远不会出现 $b_i>b_{i+1}>b_{i+2}$ 这种情况。  
而如果在 $b_i<b_{i+1}$ 的下标上执行操作 $1$，逆序对的数量会增加 $1$，而不是减少 $1$。这样即使一次操作 $2$ 可以减少 $3$ 个逆序对，也不可能让 $f(b)<g(b)$。  
因此在这种情况下有 $f(b)=g(b)$。
对于每个元素 $a_i$，我们定义：
- $l_i$：满足 $a_{l_i} > a_i$ 的最大下标 $< i$；
- $r_i$：满足 $a_{r_i} < a_i$ 的最小下标 $> i$。
那么对于一个区间查询 $[l, r]$，答案为 **NO** 当且仅当存在某个区间 $[l_i, r_i]$ 完全包含在 $[l, r]$ 内。
为了回答多个查询，可以预处理：对每个 $l$ 找到最小的 $r$，使得对于所有 $[l, x] (x \ge r)$ 的答案都是 **NO**。
时间复杂度为 $O(n)$（如果用单调栈求解 $l_i,r_i$）。  
$O(n\log n)$ 的解法也能通过。
## my(WA)
找到 $a, b, \dots c, d$ ，如果 $a > b \land c > d \land(a > c \lor b > d)$ ，就可以确定是 No
错误点在于，该条件为 **充分性条件而非必要条件** 。实际上如果你举个反例，很容易构造出 $c > a > d > b$ 的例子。随后中间区域可以划分出三个区块，考虑中间那个区块，构造出 $c > a > m > d > b$ ，此时可以交换 $a, b$ 和 $c, d$ 得到 $a > m > d$ 。如图
![[2139D.png]]
