---
title: D. Fibonacci Paths
date: 2025-12-12
last_clear: 2025-12-12
tags:
  - div2
  - tag/dp
  - tag/图论/dag
  - tag/thinking
  - starslik
grasp: 3
value: 5
difficulty:
optional_difficulty:
source:
article:
---
本题值得学习的地方主要是 `dp` 状态的巧妙设计，以及对本题图性质的理解。
```cpp showLineNumbers
void solve()
{
    // 如何计算呢？
    // 如果我从小到大考虑每个顶点
    // 感觉如果考虑每条边的话，是不是每条边都已经对应了一个fib序列？
    // 这样有什么优势吗？
    // 如果考虑所有的fib序列，每个fib序列中有若干dag, 直接在dag上计数？
    // dag怎么计数呢，似乎很多方法呢
    // 对吗，对，边唯一对应，那么组成的路径也是唯一的
    // 复杂度？似乎很低
    map<pair<i64, i64>, vector<pair<int, int>>> dag;

    int n, m;
    cin >> n >> m;
    auto get_unique = [](i64 x, i64 y) -> pair<i64, i64> {
        while (true) {
            i64 z = y - x;
            if (z <= 0) {
                return {x, y};
            } else {
                y = x;
                x = z;
            }
        }
    };
    vector<i64> arr(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    Z ans = 0;
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        auto res = get_unique(arr[u], arr[v]);
        dag[res].pb({u, v});
    }
    vector<Z>           dp(n + 1);
    vector<vector<int>> go(n + 1);
    auto                killone = [&](i64 hed, vector<pair<int, int>> edge) {
        vector<int> point;
        for (auto [u, v] : edge) {
            point.pb(u);
            point.pb(v);
        }
        sor(point);
        point.erase(unique(all(point)), point.end());
        for (auto u : point) {
            go[u].clear();
            dp[u] = 1;
        }
        for (auto [u, v] : edge) {
            if (arr[u] == arr[v]) {
                dp[v] += 1;
            } else {
                go[u].pb(v);
            }
        }
        sort(all(point), [&](int a, int b) {
            if (arr[a] == hed && arr[b] != hed) {
                return true;
            }
            if (arr[a] != hed && arr[b] == hed) {
                return false;
            }
            return arr[a] < arr[b];
        });
        for (int i : point) {
            ans += dp[i] - 1;
            for (int v : go[i]) {
                dp[v] += dp[i];
            }
        }
    };
    for (auto [_, v] : dag) {
        killone(_.fi, v);
    }
    cout << ans << '\n';
}

```
每条有向边对应于一个fib序列这个很明显，问题就是如何进行拓扑排序。我这没有想起来可以边化点后直接跑，而是进行了复杂的分类后再跑，导致实现很差。
这里是改进后的代码，参考starslik
``` cpp showLineNumbers
struct Line {
    int u, v;
    ll w;

    bool operator<(const Line& ot) { return w < ot.w; }
};

constexpr i64 P = 998244353;

ll arr[200000];

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<map<ll, ll>> dp(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    vector<Line> edges;
    for (int i = 0; i < m; i++) {
        Line ln;
        cin >> ln.u >> ln.v;
        ln.u--, ln.v--;
        ln.w = arr[ln.u] + arr[ln.v];
        edges.pb(ln);
    }
    sor(edges);
    i64 ans = 0;
    for (int i = 0; i < m; i++) {
        i64 cur = dp[edges[i].u][arr[edges[i].v]];
        ans     = (cur + ans + 1) % P;
        dp[edges[i].v][edges[i].w] += cur + 1;
        dp[edges[i].v][edges[i].w] %= P;
    }
    cout << ans << '\n';
}
```
