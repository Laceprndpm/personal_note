---
title: E. Remove at the lowest cost
date: 2025-12-12
last_clear: 2025-12-12
tags:
  - div2
  - tag/数据结构/树/CartesianTree
  - tag/单调栈
  - 离线
  - tag/贪心
  - tag/thinking/reverse
  - tag/数据结构/线段树
grasp: 2
value: 5
difficulty: 2400
optional_difficulty:
source: https://codeforces.com/contest/2176/problem/E
article:
---

``` cpp showLineNumbers title="starsilk"

void solve()
{
    // 我可以预处理出每个值可以负责的[l, r]，类似笛卡尔树
    // 类似最小生成树?
    // 如果存在i, j, k，其中k是所有代价中最小的，那么让k尽可能地吃他区间内的内容
    // 所以区间[l, r]中，剩下的一定是最大那个元素，且这样做代价一定最小?
    // 怎么证明他是优的？
    // 笛卡尔树的lft和rgt是所有小于他本身的值的子树，所以如果不存在外部消去，一定是内部的，感觉有点道理？
    // 那么如何求解呢，子树代价为k,只剩树根，然后合并时尝试用自身或者左子树解决右子树？
    // 直接先dfs预处理，从上往下取min后，就可以得出移除每个点的最低代价和以0代价移除的最早时间

    int n;
    cin >> n;
    vector<int> arr(n + 1);
    vector<i64> crr(n + 1);
    vector<int> prr(n + 1);
    vector<i64> ans(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> crr[i];
    }
    vector<int> tt(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> prr[i];
        tt[prr[i]] = i;
    }
    vector<array<int, 2>> child(n + 1, {0});
    int                   ptr = 0;
    for (int i = 1; i <= n; i++) {
        while (ptr > 0 && arr[stk[ptr - 1]] < arr[i]) {
            child[i][0] = stk[ptr - 1];
            ptr--;
        }
        stk[ptr] = i;
        ptr++;
    }
    ptr = 0;
    for (int i = n; i >= 1; i--) {
        while (ptr > 0 && arr[stk[ptr - 1]] <= arr[i]) {
            child[i][1] = stk[ptr - 1];
            ptr--;
        }
        stk[ptr] = i;
        ptr++;
    }
    int  rt   = stk[0];
    auto dfs1 = [&](this auto&& self, int u) -> void {
        for (int j = 0; j < 2; j++) {
            if (child[u][j]) {
                self(child[u][j]);
                if (arr[child[u][j]] == arr[u]) {
                    crr[u] = min(crr[u], crr[child[u][j]]);
                    tt[u]  = min(tt[u], tt[child[u][j]]);
                }
            }
        }
    };
    auto dfs2 = [&](this auto&& self, int u) -> void {
        for (int j = 0; j < 2; j++) {
            if (child[u][j]) {
                crr[child[u][j]] = min(crr[child[u][j]], crr[u]);
                tt[child[u][j]]  = min(tt[child[u][j]], tt[u]);
                self(child[u][j]);
            }
        }
    };
    dfs1(rt);
    dfs2(rt);
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < 2; j++) {
            if (child[i][j]) {
                ans[tt[child[i][j]] - 1] += crr[child[i][j]];
            }
        }
    }
    for (int i = n; i >= 1; i--) {
        ans[i - 1] += ans[i];
    }
    for (int i = 0; i <= n; i++) {
        cout << ans[i] << " \n"[i == n];
    }
}
```
也可以用线段树直接模拟，确定每个数负责的区间，并且把贡献直接记录在每个数上。
```cpp showLineNumbers
const int EMPTY = -1;
struct Tag {
  int v = EMPTY;
  Tag operator+(const Tag &rhs) const {
    if (rhs.v != EMPTY) return rhs;
    return *this;
  }
};
struct Node {
  int v = 0, len = 1;
  i64 sum = 0;
  Node operator+(const Node &rhs) const {
    return {
      max(v, rhs.v),
      len + rhs.len,
      sum + rhs.sum
    };
  }
  template<typename Tag>
  bool apply(const Tag& tag) {
    if (tag.v != EMPTY) {
      v = tag.v;
      sum = (i64)tag.v * len;
    }
    return false;
  }
};
void solve() {
  int n;
  cin >> n;
  vector<int> a(n), c(n), p(n);
  for (auto &x : a) cin >> x;
  for (auto &x : c) cin >> x;
  for (auto &x : p) cin >> x;
  auto prev = get_next_prev(a, true); // 单调栈模版
  auto next = get_next_prev(a);
  vector<int> rank(n);
  iota(rank.begin(), rank.end(), 0);  
  ranges::sort(rank, [&](int a, int b) {
    return c[a] > c[b];
  });
  seg_tree<Node, true, Tag> seg(n - 1);
  for (int i = 0; i < n; i ++) {
    int x = rank[i];
    int left = prev[x] + 1, right = next[x] - 1;
    seg.update(left, right, {c[x]});
  }
  cout << seg.top().sum - seg.top().v << ' ';
  for (auto x : p) {
    x --;
    int left = prev[x] + 1, right = next[x] - 1;
    seg.update(left, right, {0});
    cout << seg.top().sum - seg.top().v << ' ';
  }
  cout << '\n';
}
```
