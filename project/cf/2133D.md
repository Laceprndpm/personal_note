---
title: D. Chicken Jockey
date: 2025-08-25
last_clear: 2025-08-25
tags:
  - tag/dp
grasp: 2
difficulty: 1800
source: https://codeforces.com/contest/2133/problem/D
article:
---
# 题意
一个鸡骑士由 $n$ 个生物叠在一起形成栈，编号从下到上依次为$1,2,\dots,n$ 。  
第 i 个生物的初始生命值为 $h_i$​。

Steve 可以进行攻击。
- 每次攻击可以使任意一个生物的生命值减少 1。
- 当某个生物的生命值降至 0 或以下时，该生物死亡并从栈中移除。
- 与其相邻的上方所有生物会整体掉落，形成一个新的栈。
- 在这个新栈中，**最底层生物会因掉落受到摔落伤害**：如果它在掉落前位于原栈的第 $k$ 层（即下面有 $k-1$ 个生物），那么它会额外受到 $k−1$ 点伤害。

若因此导致该生物死亡，则它上方的生物继续掉落，伤害按同样的规则重新计算，直到不再有新的生物死亡为止。

Steve 的剑耐久有限，他希望知道：**最少需要多少次攻击才能杀死所有生物？**

---
# Solution
## 1
这种解法与我一开始的想法类似
```text
因为每一个人最多受到一次摔落伤害，而且是越高伤害越高，所以从高往低应该没错
dp[i] 表示上一个杀死的点是 i 的最小的代价
dp[i] = for j : min(dp[j] + sum{[i, j - 1] - (j - i)})
```
但是后来我实现能力有限
```c++
#include <bits/stdc++.h>
using namespace std;

#define int  long long
#define MAXN 200005
#define INF  (int)1e18

// a[1] 一定是硬打打死的
// a[2] 如果死在 a[1] 前面，摔落伤害就浪费了，最少也要把 a[2] 打成 1 再来
// 把这个序列先削成形如一个数带一个摔落伤害带一堆 1 的形式，然后从后面往前面摔，摔死

// 从后往前做 DP，枚举上一个考虑的点
// dp[i] 表示把 [i,n] 按照上面的策略来做的最小代价，钦定 i 是一个队头

int n, hi[MAXN], dp[MAXN], prefix[MAXN], g[MAXN];

inline void solve()
{
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++) scanf("%lld", &hi[i]), prefix[i] = prefix[i - 1] + hi[i], dp[i] = INF;
    g[n + 1] = prefix[n] - (n - 1);
    dp[n] = hi[n], g[n] = dp[n] + prefix[n - 1] - (n - 2);
    for (int i = n - 1, sufmin = INF; i >= 1; i--) {
        // 第一种，i,i+1 都强行打死
        dp[i] = min(dp[i], dp[i + 1] + hi[i]);
        // 第二种，i+1 用 i 摔死
        sufmin = min(sufmin, g[i + 2]);
        // for j in (i + 2), val chmin = 
        dp[i]  = min(dp[i], hi[i] + max(0ll, hi[i + 1] - i) - prefix[i + 1] + i + sufmin);
        g[i]   = dp[i] + prefix[i - 1] - (i - 2);
    }
    printf("%lld\n", dp[1]);
    for (int i = 1; i <= n + 1; i++) dp[i] = g[i] = hi[i] = prefix[i] = 0;
}

signed main()
{
    int testcase;
    scanf("%lld", &testcase);
    while (testcase--) solve();
    return 0;
}
```

## 2
```c++
i64 f(i64 x, i64 h) {
    return std::max(0ll, x - h);
}
/*
神秘dp

如果一个物品有掉落伤害，那它是怎么样的，要么掉落伤害为1，要么直接掉到最下面

dp[i][0] 表示当前位置信吃了满的掉落伤害的话， 需要最少多少步解决整个后缀
dp[i][1] 表示当前位置信直接被杀的话，        需要最少多少步解决整个后缀
dp[i][2] 表示当前位置信吃了1层的掉落伤害的话， 需要最少多少步解决整个后缀
*/

void solve() {
    int n;
    std::cin >> n;

    std::vector<int> a(n);
    for (auto &i : a) std::cin >> i;

    std::vector dp(n, std::vector<i64>(3));
    dp[n - 1][0] = f(a[n - 1], n - 1);
    dp[n - 1][1] = a[n - 1];
    dp[n - 1][2] = f(a[n - 1], 1);
    for (int i = n - 2; i >= 0; i--) {
        // 吃满掉落伤害 那后面的位置要么允许直接击杀，要么留着只吃一层掉落伤害再击杀
        dp[i][0] = f(a[i], i) + std::min(dp[i + 1][1], dp[i + 1][2]);
        // 直接击杀 那后面的要么需要直接击杀，要么需要吃满掉落伤害
        dp[i][1] = a[i] + std::min(dp[i + 1][0], dp[i + 1][1]);
        // 只吃一层掉落伤害 那后面的位置只吃一层掉落伤害 或者直接击杀
        dp[i][2] = f(a[i], 1) + std::min(dp[i + 1][2], dp[i + 1][1]);
    }

    std::cout << dp[0][1] << "\n";
}
```

## std
### Hint 1
How many times can a mob take fall damage?
### Hint 2
If a mob takes more than $1$ fall damage, what about the mob below it?
### Hint 3
Use DP.
### Solution
Let's make a few observations. First of all, if a mob takes fall damage, it ends up at the bottom of a stack. This means a mob never takes fall damage more than once, because after taking fall damage there are no more mobs below it that it can fall off of. Secondly, if a mob takes more than $1$ fall damage, the mob below must have been killed without taking fall damage, otherwise it would have been at the bottom of the stack and hence the mob above would only have $1$ mob below it and take $1$ fall damage. Therefore the mob below must take $h_i$ attacks to kill, regardless of whether it is in the original stack or if other mobs below it had fallen off and taken damage. This means that if a mob should take more than $1$ fall damage, it is best to do so in the original stack, as that will maximise the fall damage without incurring any additional attacks. This seems like a very local choice: for each mob $i$ we either kill it directly, let it take $i - 1$ fall damage by killing the mob below it directly, or let it take $1$ fall damage by falling down when the mob below it dies. So we could let $dp[i]$ be the minimum attacks needed to kill all the mobs up to mob $i$. Clearly $dp[0] = 0$ and $dp[1] = h_1$. For $i \ge 2$, we either let it take $1$ fall damage which costs $dp[i - 1] + h_i - 1$ attacks, or let it take maximum fall damage which costs $dp[i - 2] + h_{i - 1} + \text{max}(0, h_i - (i - 1))$ attacks; we set $dp[i]$ to the smaller of those two values. The answer is then $dp[n]$.
### Code
```python
t = int(input())
for test in range(t):
    n = int(input())
    h = list(map(int, input().split()))
    dp = [0] * (n + 1)
    dp[1] = h[0]
    for i in range(1, n):
        dp[i + 1] = min(dp[i] + h[i] - 1, dp[i - 1] + h[i - 1] + max(0, h[i] - i))
    print(dp[n])
```
