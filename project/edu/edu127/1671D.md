---
title: D. Insert a Progression
date: 2025-11-27
last_clear: 2025-11-27
tags:
  - edu
  - tag/贪心
  - tag/细心
grasp: 4
value: 5
difficulty: 1600
optional_difficulty:
source: https://codeforces.com/contest/1671/problem/D
article:
---
首先注意到，在 $a \le x \le b$ 间插入 $x$ 是免费的，所以方法很明确：
插入 $1$ 和 $x$ 即可。
我的做法是，直接找到 $1$ 和 $x$ 各自最低代价，随后特判掉他们无代价的情况，其实就是因为 $1$ 被插入了，所以如果 $mx \ge x$ ，则 $x$ 代价必然是 $0$ 。对 $1$ 同理。
```cpp showLineNumbers
void solve()
{
    i64 n, x;
    cin >> n >> x;
    vector<i64> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    if (n == 1) {
        x = max(x, arr[0]);
        cout << x - 1 << '\n';
        return;
    }
    auto [mn, mx] = minmax_element(all(arr));
    i64 base      = 0;
    for (int i = 0; i < n - 1; i++) {
        base += abs(arr[i] - arr[i + 1]);
    }
    i64 mncost = min(abs(arr[0] - 1), abs(arr[n - 1] - 1));
    i64 mxcost = min(abs(arr[0] - x), abs(arr[n - 1] - x));
    for (int i = 0; i < n - 1; i++) {
        mncost = min(mncost, abs(arr[i] - 1) + abs(arr[i + 1] - 1) - abs(arr[i + 1] - arr[i]));
        mxcost = min(mxcost, abs(arr[i] - x) + abs(arr[i + 1] - x) - abs(arr[i + 1] - arr[i]));
    }
    if (*mn <= 1) {
        mncost = 0;
    }
    if (*mx >= x) {
        mxcost = 0;
    }
    cout << mncost + mxcost + base << '\n';
}
```
官解则更暴力更细致一些，直接暴力穷举了所有插入方法：分开插和一起插，通过，然后就直接实现即可。
```cpp showLineNumbers
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)

using namespace std;

int main() {
    int t;
    scanf("%d", &t);
    forn(_, t){
        int n, x;
        scanf("%d%d", &n, &x);
        vector<int> a(n);
        forn(i, n) scanf("%d", &a[i]);
        long long ans = 1e18;
        long long cur = 0;
        forn(i, n - 1){
            cur += abs(a[i] - a[i + 1]);
        }
        forn(_, 2){
            long long mn = abs(a[0] - 1);
            ans = min(ans, cur + abs(a[0] - x) + (x - 1));
            forn(i, n - 1){
                ans = min(ans, cur + mn - abs(a[i] - a[i + 1]) + abs(a[i] - x) + abs(a[i + 1] - x));
                ans = min(ans, cur - abs(a[i] - a[i + 1]) + abs(a[i] - x) + abs(a[i + 1] - 1) + (x - 1));
                mn = min(mn, 0ll - abs(a[i] - a[i + 1]) + abs(a[i] - 1) + abs(a[i + 1] - 1));
            }
            ans = min(ans, cur + mn + abs(a.back() - x));
            reverse(a.begin(), a.end());
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```
本题在复习时考虑不细致，导致频繁wa，需要思维更细致全面些。