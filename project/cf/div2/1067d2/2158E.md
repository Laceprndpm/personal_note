---
title: E. Sink
date: 2025-12-02
last_clear: 2025-12-02
tags:
  - div2
  - tag/dsu
  - tag/thinking/可持久化
grasp: 2
value: 5
difficulty: 2500
optional_difficulty:
source: https://codeforces.com/contest/2158/problem/E
article:
---
如果每个单元格的值都不一样，你会怎么处理？
那么只需要逐询问模拟即可

当一些单元格具有相同的值时，将等值单元格的连接部分视为一个组是否很自然？
对于这样一个组，如何确定整个组是否**需要一个洞**？
对于这样一个组，只需要看边上是否有val小于他的，否则一定需要一个洞

进行一次查询（减少一个单元格的值）后，美观度是否会增加 1 以上？  
上一网格中有多少组可以不再需要洞，因为它们现在有了一个严格意义上更小的邻居？
不会，最坏的情况就是减少后，这个单元格变成了一个洞，其他的则完全没有影响。也就是说，可能会一次性减少多个，但最多添加一个。
周围相邻的组如果大于当前格，则不需要有洞。

如何将网格的演变建模为一个图，其中的边反映网格中的相邻关系或同一单元的不同版本之间的 "时间相邻关系"？
可持久化的dsu，用新建节点维护曾经的相邻关系

如何将网格的演变建模为一个图，其中的边反映网格中的相邻关系或同一单元的不同版本之间的 "时间相邻关系"？
持久化图
只记录空间相邻边，不添加时间相邻边，以将原先的单元格单独分组。

因为本题中，只需要维护哪些组是important的，所以不需要真正意义上的断开，**如果一个原先属于一个组的单元被减少了，那么这一个组将来都不会被选中作为important。这是关键观察**
```cpp showLineNumbers
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<vector<int>> val(n + 1, vector<int>(m + 1));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> val[i][j];
        }
    }
    int q;
    cin >> q;
    DSU                 dsu(n * m + q + 50);  // 理论n * m + q + 1，保险多开50
    vector<int>         import(n * m + q + 50, 1);
    vector<vector<int>> real(n + 1, vector<int>(m + 1));
    auto                adj = [&](int x, int y) {
        vector<array<int, 2>> res;
        if (x > 1) res.pb({x - 1, y});
        if (x < n) res.pb({x + 1, y});
        if (y > 1) res.pb({x, y - 1});
        if (y < m) res.pb({x, y + 1});
        return res;
    };
    int cnt = n * m + 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            real[i][j] = (i - 1) * m + j;
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            for (auto [nx, ny] : adj(i, j)) {
                if (val[i][j] == val[nx][ny]) {
                    dsu.merge(real[i][j], real[nx][ny]);
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            for (auto [nx, ny] : adj(i, j)) {
                if (val[nx][ny] < val[i][j]) {
                    import[dsu.find(real[i][j])] = 0;
                }
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (dsu.find(real[i][j]) == real[i][j]) ans += import[real[i][j]];
        }
    }
    cout << ans << '\n';
    while (q--) {
        int r, c, x;
        cin >> r >> c >> x;
        x = val[r][c] - x;
        set<int> st;
        int      mn = INF;
        for (auto [nx, ny] : adj(r, c)) {
            mn = min(mn, val[nx][ny]);
            st.ins(dsu.find(real[nx][ny]));
        }
        st.ins(dsu.find(real[r][c]));
        for (auto& y : st) {
            ans -= import[y];
        }
        for (auto [nx, ny] : adj(r, c)) {
            if (val[nx][ny] > x) {
                import[dsu.find(real[nx][ny])] = 0;
            }
        }
        real[r][c] = cnt++;
        val[r][c]  = x;
        if (mn < x) {
            import[real[r][c]] = 0;
        } else {
            import[real[r][c]] = 1;
        }
        for (auto [nx, ny] : adj(r, c)) {
            if (val[nx][ny] == x) {
                import[dsu.find(real[nx][ny])] &= import[dsu.find(real[r][c])];
                dsu.merge(real[nx][ny], real[r][c]);
            }
        }
        st.clear();
        for (auto [nx, ny] : adj(r, c)) {
            st.ins(dsu.find(real[nx][ny]));
        }
        st.ins(dsu.find(real[r][c]));
        for (int y : st) {
            ans += import[y];
        }
        cout << ans << '\n';
    }
}
```
